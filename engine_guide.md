Вот ваш текст, оформленный в виде `.md` файла с использованием синтаксиса Markdown:

markdown

Copy

# Гайд по супер движку

## Глава 1: Векторы

Движок физический, так что это основа. Простой класс `Vector` позволяет задать вектор и проводить все важные базовые операции с векторами.

С методами операций думаю понятно, если нет, то почитайте про векторы как математический объект. Методы магические, поэтому просто используйте дефолтные операции. Пример:

```python
Vector(3, 5) + Vector(7, 2)
```

Из остальных методов может быть непонятен метод `normalize` и метод класса `unit_from_angle`.

*   `normalize` приводит любой вектор к такому, длина которого = 1. Это полезно для задания направления.
    
*   `unit_from_angle` создает единичный вектор исходя из угла. Это костыль, который я придумал, чтобы не рассчитывать для угла единичные векторы каждый раз. Например, если угол 90, то это соответствует направлению вниз (т.к. у нас координаты в pygame повернуты). Используйте этот метод для задания направления в векторных величинах (можно и рассчитывать, но это не удобно). Не забывайте, что это именно метод класса.
    

## Глава 2: Векторные величины

Основные векторные величины в движке — это скорость и ускорение. В основе векторной величины лежит 2 составляющих:

1.  **Единичный вектор (direction)** — указывающий направление.
    
2.  **Сила (magnitude)** — это абстракция для упрощения. Разделение на 2 компоненты вместо голого вектора (который в конечном итоге рассчитывается на основе компонент) позволяет управлять направлением и силой по отдельности.
    

### Скорость

Вот пример создания объекта скорости:

```python
Speed(10.1, Vector.unit_from_angle(270))
```

Вот тут и пригождается метод `unit_from_angle`, т.к. `direction` — это единичный вектор, то можно его вот так просто задать. Можно и так:

```python
Speed(10.1, Vector(1, 0))
```

Так же, как и с обычными векторами, можно производить сложение:

```python
Speed(1, Vector.unit_from_angle(78)) + Speed(2, Vector.unit_from_angle(0))
```

Основные методы `Speed` (помимо магических для операций):

*   `get_vector` — возвращает сам преобразованный вектор скорости (`Vector`).
    
*   `get_x_projection` — проекция на ось x.
    
*   `get_y_projection` — проекция на ось y.
    

Это основа движения в игре.

### Ускорение

Ускорение (класс `Acceleration`) работает точно так же, как скорость. Они полиморфны, то есть вы можете прибавить к скорости ускорение:

```python
Speed(1, Vector.unit_from_angle(78)) + Acceleration(10, Vector.unit_from_angle(0))
```

Как пример, таким образом можно задать силу тяжести, просто на каждом тике прибавляем вектор ускорения вниз с силой 9.8:

```python
self.speed += Acceleration(9.8, Vector.unit_from_angle(90))
```

## Глава 3: Объекты

Самая важная часть. Самый базовый класс объекта — это `GameObject`, от него наследуется все остальное. Вот параметры для создания `GameObject`:

```python
GameObject(x, y, width, height, sprite_path=None, animation=None)
```

Думаю, тут все, кроме `animation`, понятно, но об анимациях чуть позже. Все объекты имеют основные атрибуты, такие как `x`, `y`, `width`, `height`, `sprite` (если указан). Важно отметить, что атрибуты размеров и координат — это `property`. Истинно информация хранится в объекте `Rect`, в атрибуте `rect`, но чаще всего лучше используйте просто `self.x` или `self.height` для упрощения.

Вот вспомогательные методы `GameObject`:

*   `check_collide` — проверка столкновения с другим объектом.
    
*   `check_collide_list` — возвращает список индексов в списке объектов, с которыми столкнулся `self`.
    
*   `set_sprite` — установка нового спрайта. Кстати, если у объекта не указывать спрайт, то он просто будет зеленым прямоугольником.
    

А вот основные методы, которые определяют поведение объекта в дочерних классах:

*   `resolve_collisions(self, others: list)` — на вход принимает список всех игровых объектов (вообще всех) и должен разрешать коллизии. В цикле перебираем объекты и совершаем определенные действия, например, получаем урон или не даем провалиться в стену. По умолчанию метод просто не дает пройти сквозь остальные объекты, но его надо будет часто переопределять. Об этом позже.
    
*   `draw` — метод отрисовки, исходя из анимации и спрайта отрисовывает объект.
    
*   `move` — метод движения, изменяет положение объекта в зависимости от ускорения и скорости (есть у дочерних классов, у самого `GameObject` нет, т.к. он статичен, но во всех двигающихся классах должен быть, вызывается в `update` при наличии).
    
*   `update` — самый важный метод, вызывается у каждого объекта при каждом тике. По умолчанию выглядит так:
    

```python
def update(self, screen, game_objects: list):
    if hasattr(self, 'move'):
        self.move()
    self.resolve_collisions(game_objects)
    self.draw(screen)
```

То есть сначала мы двигаем объект, потом обрабатываем столкновения и потом отрисовываем.

### Дочерние классы GameObject

#### VelocityObject

Класс для объектов, движущихся линейно. Дополнительно в качестве аргумента при инициализации принимает необязательный `v0` (экземпляр класса `Speed`). Скорость можно изменить или прочитать через атрибут `speed`. Метод `move` переопределен так:

```python
def move(self):
    self.x += self.speed.get_x_projection()
    self.y += self.speed.get_y_projection()
```

#### AcceleratedObject

Наследуется от `VelocityObject`. Принимает при инициализации все то, что `GameObject`, а также необязательные `v0` и `a0` (экземпляр класса `Acceleration`). Метод `move` переопределен для движения равноускоренно:

```python
def move(self):
    super().move()
    self.speed = self.speed + self.acceleration
    self.speed.magnitude = self.speed.magnitude * 0.91
```

Вот эта вот `0.91` — это сопротивление воздуха. Таким образом, мы ограничиваем скорость, и бесконечно разгоняться не получится.

#### Player

Класс игрока, наследуется от `AcceleratedObject`. Это уже не совсем относится к движку, ну просто прояснить, что он есть.

#### Enemy

Класс сущности, наследуется от `AcceleratedObject`. Просто мобы, пока ничего не делает.

## Глава 4: Анимации

Анимации имеют отдельный класс, а не встроены в `game_object`:

```python
class Animation:
    def __init__(self, frames_paths, frame_duration):
        """
        Во frames указать пути до всех кадров анимации.
        :param frames_paths: list[str]
        """
        self.frames = [pygame.image.load(frames_path) for frames_path in frames_paths]
        self.frame_duration = frame_duration
        self.current_frame = 0
        self.last_update_time = pygame.time.get_ticks()

    def update(self):
        now = pygame.time.get_ticks()
        if now - self.last_update_time > self.frame_duration:
            self.last_update_time = now
            self.current_frame = (self.current_frame + 1) % len(self.frames)

    def get_current_frame(self):
        return self.frames[self.current_frame]
```

По сути, класс анимации просто отдает нужный кадр в зависимости от времени. В игровом объекте экземпляр класса `Animation` содержится в `self.animation`. В методе `draw`, если у объекта есть анимация, то получается ее текущий кадр и задается для `self.sprite` и отрисовывается:

```python
if self.animation:
    self.animation.update()
    self.sprite = pygame.transform.scale(self.animation.get_current_frame(), (self.width, self.height))

if self.sprite:
    screen.blit(self.sprite, (self.x, self.y))
else:
    new_rect = Rect(self.x, self.y, self.width, self.height)
    pygame.draw.rect(screen, (0, 255, 0), new_rect)

Анимацией объекта можно манипулировать, меняя ее на другую или замедляя. Вот как можно менять анимацию:
```

```python
self.animation.frame_duration = 2  # меняем длину кадра
self.animation.current_frame = 3  # меняем текущий кадр
```
Вот пример создания объекта с анимацией:

```python
game_object_animation = Animation(
    [f'../assets/adventurer-0{i}.png' for i in range(1, 6)], 100)

game_object = Player(0, -100, 100, 120,
                     sprite_path="../assets/adventurer-00.png",
                     a0=Acceleration(1, Vector.unit_from_angle(90)),
                     animation=game_object_animation)
```

Напомню, что анимации можно задавать для всех объектов, но они не обязательны. Можно указать только 1 спрайт в `sprite_path`, а можно указать и то, и то.

## Глава 5: Проектирование и цикл игры

Рассказывать про классы, конечно, прекрасно, но хотелось бы упомянуть, как я задумываю сам процесс разработки с этим движком. В идеале весь код, вот вообще весь, должен быть в классах. Если вы создаете какой-то новый объект, то наследуйте его от классов из главы 3. Выбирайте базовый класс с умом. Той же движущейся платформе не нужно ускорение, поэтому можно взять `VelocityObject` (хоть и весь ее функционал есть в `AcceleratedObject`, но это повышает логичность кода).

В основном вам нужно переопределять 4 основных метода: `move`, `draw`, `resolve_collisions`, `update`. По сути, только переопределяя их, можно сделать любой объект любой сложности. Все эти методы в конечном итоге будут вызваны у каждого игрового объекта, абсолютно всех классов, которые наследуются от `GameObject` либо от его дочерних классов. В основном игровом цикле у каждого объекта вызывается метод `update`, который в свою очередь вызывает методы `move`, `draw`, `resolve_collisions`:

```python
all_game_objects = GameObject.all_game_objects
for object in all_game_objects:
    object.update(screen, [obj for obj in all_game_objects if obj != object])
```

### Кк переопределять методы?

*   **move**: переопределяйте, если вам нужно особое движение объекта. Можно сначала вызвать `super().move()`, а потом как-то еще изменить координаты.
    
*   **draw**: если нужна особая отрисовка. Например, в классе игрока он переопределен так, чтобы спрайт отражался по горизонтали в зависимости от того, куда смотрит игрок.
    
*   **resolve_collisions**: этот метод будет переопределяться чаще всего. Вы можете управлять поведением объекта в зависимости от того, с чем он столкнулся. Например, если игрок столкнулся со стеной, то ему надо не дать пройти через нее, а если с сундуком, то надо дать ему какой-то предмет, если с врагом, то снизить HP. Вот пример, как это можно сделать:
    

```python
def resolve_collisions(self, others):
    for obj in others:
        if self.check_collide(obj):
            if type(obj) == Chest:
                self.inventory.give('sword')
            elif type(obj) == Enemy:
                self.hp -= 10
```

В общем, если делать выводы, то мне хотелось бы, чтобы вы грамотно использовали наследование и переопределение методов.